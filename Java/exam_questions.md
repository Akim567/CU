1. Примитивные типы данных и операции над ними. Расскажите про примитивные типы Java, их диапазоны и особенности
   хранения. Объясните, что такое специальные значения `NaN` и `Infinity` для вещественных типов и в каких ситуациях они
   появляются. Опишите неявное и явное приведение типов, возможную потерю данных при кастах, а также работу логических
   операторов (`&&`, `||`, `!`), побитовых операторов (`&`, `|`, `^`, `~`) и операций сдвига (`<<`, `>>`, `>>>`),
   включая приоритет и отличие short‑circuit логических операций от побитовых.

2. Массивы, строки, перечисления. Объясните, как объявлять, создавать и инициализировать одномерные и многомерные
   массивы. Расскажите, как узнать длину массива, как устроена индексация, что происходит при выходе за границы массива.
   Расскажите, что означает неизменяемость класса `String` и как она влияет на операции со строками. Объясните, что
   такое string pool, как JVM хранит строковые литералы, чем отличаются выражения `var abc = "abc"` и
   `var abc = new String("abc")`, как работает метод `intern()` и когда его использование может быть полезным или
   вредным. Приведите примеры основных методов `String`. Расскажите про перечисления, объясните, как и зачем
   использовать `enum` с полями и методами.

3. Управляющие конструкции. Опишите конструкции ветвления `if-else` и `switch`. Расскажите про циклы `for`, enhanced
   `for`, `while`, `do-while`, их отличия и типичные сценарии использования. Объясните назначение операторов `break` и
   `continue`.

4. Методы: объявление, вызов и перегрузка. Расскажите, как объявляется метод, как происходит вызов метода и передача
   аргументов. Объясните, что такое перегрузка методов (overload), по каким правилам компилятор выбирает подходящую
   перегруженную версию (в том числе при автоприведениях), и чем перегрузка принципиально отличается от
   переопределения.

5. Стек и куча. Присваивание, сравнение, копирование. Объясните, что такое стек (stack) и куча (heap) в JVM, какие
   данные хранятся в каждом из них, как происходит создание объектов. Что такое `null` и чем оно опасно. Объясните
   причины возникновения `NullPointerException`, `StackOverflowError` и `OutOfMemoryError`. Объясните, чем копирование
   примитивного значения отличается от копирования ссылки на объект, что происходит при присваивании одной ссылочной
   переменной другой, и как изменение объекта через одну ссылку отражается на других. Расскажите, как работает оператор
   `==` и чем он отличается от метода `equals()` при сравнении объектов. Объясните разницу между копированием ссылки и
   фактическим копированием объекта.

6. Классы, конструкторы. Расскажите, из чего состоит класс, как создается экземпляр класса и как осуществляется доступ к
   полям и методам. Объясните роль ключевого слова `this`; что такое shadowing; какие значения по умолчанию получают
   поля примитивных и ссылочных типов. Расскажите о назначении конструкторов, конструкторе по умолчанию, перегрузке
   конструкторов и вызове другого конструктора того же класса. Опишите виды вложенных классов, а также анонимные классы;
   их связь с внешним объектом и доступ к внешним переменным.

7. `final`, `static`. Объясните, чем `final` для поля отличается от неизменяемости самого объекта, как и где можно
   использовать `final`. Расскажите, как корректно реализовать неизменяемый класс. Расскажите про `record`, его
   canonical и compact constructor. Расскажите, чем отличаются статические поля и методы от нестатических и в каких
   случаях имеет смысл использовать каждый из этих вариантов. Объясните, что такое static initialization block и для
   чего он нужен. Расскажите, что обычно имеют в виду под "статическими конструкторами" и какую роль они выполняют.

8. Пакеты, модификаторы доступа, импорты. Объясните назначение пакетов, как они формируют пространства имен и влияют на
   организацию кода. Расскажите о модификаторах доступа `public`, `private`, `protected`, package‑private и о том, как
   они определяют видимость классов, полей и методов внутри пакета и между пакетами. Перечислите 4 вида import и
   объясните различия между ними, а также возможные конфликты имен и типичные ошибки, связанные с неправильными
   импортами.

9. Наследование. Объясните, как объявить наследника; какие члены базового класса доступны в подклассе с учетом
   модификаторов доступа; как вызываются конструкторы и методы базового класса. Расскажите про переопределение методов (
   override): требования к сигнатуре и модификаторам доступа и выбор версии метода при вызове. Опишите различия между
   абстрактными классами и интерфейсами и их назначение. Упомяните sealed классы и интерфейсы и их роль в ограничении
   иерархий наследования. Расскажите про приведение типов (upcasting & downcasting) и оператор `instanceof`. Сравните
   наследование с композицией и объясните, в каких случаях композиция предпочтительнее наследования.

10. Исключения. Расскажите об иерархии исключений и различиях между checked и unchecked исключениями. Объясните, как и в
    каких случаях стоит создавать собственные типы исключений. Раскройте назначение оператора `throw` и ключевого слова
    `throws`, основные способы обработки ошибок и связанные с этим best practices. Опишите структуру блока
    `try-catch-finally`, варианты комбинирования нескольких `catch`, поведение блока `finally`, а также роль и
    устройство конструкции try‑with‑resources.

11. Generics. Объясните, как объявлять и использовать обобщенные классы и интерфейсы, где можно использовать параметр
    типа. Расскажите об объявлении и вызове обобщенных методов, о создании экземпляров generic‑классов с помощью
    оператора `<>` и использовании нескольких параметров типа. Объясните, что такое стирание типов и как оно влияет на
    generics в рантайме: почему нельзя создать `new T()`, объявить `static T field` и использовать
    `obj instanceof Some<T>`. Приведите пример heap pollution и объясните, к чему это может привести.

12. Bounded types & Wildcards. Расскажите о наследовании обобщенных классов: полная и частичная спецификация параметров
    типа в подклассах. Объясните, как работают ограниченные параметры типа и множественные ограничения. Объясните, что
    такое bridge‑методы и зачем JVM их генерирует. Расскажите про три вида wildcard. Приведите и объясните правило PECS
    и покажите на примерах сигнатур методов, как корректно использовать wildcards.

13. Коллекции. Опишите иерархию интерфейсов коллекций: `Iterable`, `Collection`, `List`, `Set`, `Queue`, `Deque`.
    Расскажите про ключевые методы интерфейса `Collection` и специфические методы `List` и `Queue`. Расскажите, зачем
    нужны абстрактные классы: `AbstractCollection`, `AbstractList`, `AbstractSet` и т.д. Перечислите основные
    реализации, кратко указав их особенности и типичные сценарии использования. Объясните, что такое неизменяемые
    коллекции, как их создавать через фабричные методы и обертки, в чем разница между полностью immutable‑коллекцией и
    read‑only view. Объясните роль интерфейса `Iterable` и метода `iterator()`, работу `Iterator` и связь с циклом
    for‑each. Расскажите о проблеме изменения коллекции во время обхода, исключении `ConcurrentModificationException` и
    способах безопасной модификации.

14. `Map`. Объясните концепцию ассоциативного массива и интерфейса `Map`, расскажите про ключевые методы. Объясните роль
    `Map.Entry`. Опишите, как устроены `HashMap` (бакеты, хэш‑функция, коллизии) и `TreeMap`. Объясните контракт между
    `equals()` и `hashCode()` и последствия его нарушения для `HashMap`/ `HashSet`. Расскажите об интерфейсе
    `Comparable`: как задается естественный порядок элементов, как он используется в `TreeMap` и `TreeSet`. Опишите
    интерфейс `Comparator` и его статические методы. Покажите на примере класса (например, `User`), как строить сложные
    компараторы.

15. Функциональные интерфейсы. Расскажите о назначении аннотации `@FunctionalInterface`, ее требованиях и ограничениях.
    Перечислите и объясните роль основных интерфейсов из `java.util.function`: `Function`, `Predicate`, `Consumer`,
    `Supplier`, `Comparator`, `BiFunction`, `BinaryOperator`. Расскажите о композиции функций через методы `andThen` и
    `compose`.

16. Лямбда-выражения и ссылки на методы. Расскажите о синтаксисе лямбда‑выражений: варианты записи параметров, варианты
    тела. Объясните, как лямбда‑выражения захватывают окружающий контекст. Упомяните внутреннюю реализацию лямбд и
    основные ограничения. Объясните виды ссылок на методы: на статический метод, на метод экземпляра, на произвольный
    экземпляр, на конструктор и конструктор массива.

17. `Optional`. Объясните, зачем нужен класс `Optional`, какие проблемы с `null` он помогает решать. Расскажите о
    способах создания `Optional` и о ключевых операциях. Перечислите основные best practices.

18. Stream API. Расскажите, что такое Stream и какие задачи он решает по сравнению с классическими циклами. Перечислите
    основные способы создания потоков, опишите ключевые промежуточные и терминальные операции. Объясните, что означает
    ленивость вычислений. Обсудите, как порядок операций и их тип (stateful/stateless) влияет на результат и
    производительность. Перечислите основные best practices.

19. Stream collectors. Расскажите об интерфейсе `Collector`: компоненты `supplier`, `accumulator`, `combiner`,
    `finisher` и как они участвуют в сборе результата, какие характеристики могут быть у коллектора. Перечислите
    стандартные коллекторы и приведите примеры их комбинаций. Объясните, как создать свой коллектор через `Collector.of`
    и опишите использование `Collectors.teeing`.

20. Аннотации. Объясните, что такое аннотации и их назначение. Приведите примеры стандартных аннотаций из JDK и их
    назначение. Опишите, как объявить собственную аннотацию и как ее применить к элементам программы. Расскажите о
    мета‑аннотациях: `@Target`, `@Retention`, `@Inherited`, `@Repeatable`. Объясните, какие типы допустимы для
    параметров аннотаций, как задавать значения по умолчанию, и какие особенности связаны с использованием специального
    имени параметра `value`.

21. Reflection. Объясните, что такое Reflection API и какие задачи он решает. Расскажите, как получить `Class<?>`, какие
    метаданные о классе можно получить. Опишите методы для поиска конструкторов, методов и полей. Объясните, чем `get*`
    отличается от `getDeclared*`, как вызывать методы через `invoke()` и создавать объекты через
    `Constructor#newInstance`; как и зачем использовать `setAccessible(true)`. Расскажите, как работать с аннотациями
    через reflection. Упомяните, какую информацию о generics можно получить, а какую — нет.

22. Gradle. Объясните, зачем нужна система сборки. Опишите структуру Gradle‑проекта: файлы `settings.gradle`,
    `build.gradle`, директории `.gradle/`, `build/`. Объясните этапы lifecycle (init -> config -> execute), понятия
    project, plugin, task. Расскажите о плагине `java`, основных тасках (`build`, `test`, `clean`), создании собственных
    задач. Расскажите про Gradle wrapper. Сравните коротко Maven и Gradle.

23. Gradle: зависимости. Расскажите о конфигурациях зависимостей: `implementation`, `api`, `compileOnly`, `runtimeOnly`,
    `testImplementation` и транзитивных зависимостях. Расскажите про управление версиями через Maven BOM и использование
    `implementation(platform("group:bom:version"))`. Опишите Gradle Version Catalog и его использование в
    `build.gradle`. Объясните, как организовать мультимодульный проект: `settings.gradle` с
    `include 'moduleA', 'moduleB'`, общие плагины и версии в корневом `build.gradle`. Объясните, как библиотеки
    распространяются через Maven‑репозитории, а также о сборке JAR и его структуре.

24. Загрузка и инициализация классов. Опишите путь исполнения кода: от исходников `.java` к файлам `.class`, далее к
    этапам загрузки и подготовки классов: loading -> linking (verification, preparation, resolution) -> initialization.
    Для каждого из этих этапов расскажите, что на нем происходит и какие ошибки могут возникать. Расскажите об иерархии
    загрузчиков классов (bootstrap, platform, application, custom ClassLoader’ы), их ролях и принципах делегирования.
    Объясните, как создать собственный ClassLoader, и к каким ошибкам может привести приведение типов между классами,
    загруженными разными загрузчиками.

25. Память JVM и сборка мусора. Расскажите о runtime data areas в JVM: heap (young/old поколения), stack, metaspace,
    code cache. Объясните, из чего состоит объект в памяти. Опишите основные семейства алгоритмов GC: copying,
    mark‑sweep, mark‑compact, generational, а также механизм stop‑the‑world. Приведите примеры реализаций GC в HotSpot и
    их ключевые особенности.

26. Исполнение байткода. Объясните, как работает интерпретатор байткода в JVM и почему одной интерпретации недостаточно.
    Расскажите о JIT‑компиляции и механизме tiered compilation (interpreted, C1, C2): какие профили собирает JVM и как
    на их основе принимается решение о компиляции. Объясните, что такое спекулятивные оптимизации и deoptimization, роль
    uncommon trap. Расскажите про оптимизацию вызова виртуальных методов (devirtualization),
    monomorphic/bimorphic/megamorphic call sites, про встраивание (inlining) и другие оптимизации (escape analysis,
    stack allocation, scalar replacement, range check elimination).