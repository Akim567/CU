### **1. Полный жизненный цикл бина: отслеживание всех этапов**

**Задача:** Создать бин, который явно демонстрирует все возможные этапы своего жизненного цикла через различные механизмы Spring, и понять их порядок выполнения.

**Действия:**

1. **Создайте класс `LifecycleDemoBean`, реализующий ВСЕ возможные механизмы жизненного цикла:**
   ```java
   import org.springframework.beans.BeansException;
   import org.springframework.beans.factory.*;
   import javax.annotation.*;
   
   public class LifecycleDemoBean implements 
         BeanNameAware, 
         BeanFactoryAware, 
         ApplicationContextAware,
         InitializingBean, 
         DisposableBean {
       
       private String name;
       
       // 1. Конструктор
       public LifecycleDemoBean() {
           System.out.println("Шаг 1: Вызов конструктора");
       }
       
       // 2. Setter-инъекция (если есть)
       public void setName(String name) {
           this.name = name;
           System.out.println("Шаг 2: Вызов сеттера для свойства 'name'");
       }
       
       // 3. BeanNameAware
       @Override
       public void setBeanName(String name) {
           System.out.println("Шаг 3: BeanNameAware.setBeanName() - имя бина: " + name);
       }
       
       // 4. BeanFactoryAware
       @Override
       public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
           System.out.println("Шаг 4: BeanFactoryAware.setBeanFactory()");
       }
       
       // 5. ApplicationContextAware
       @Override
       public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
           System.out.println("Шаг 5: ApplicationContextAware.setApplicationContext()");
       }
       
       // 6. @PostConstruct (JSR-250)
       @PostConstruct
       public void postConstruct() {
           System.out.println("Шаг 6: @PostConstruct метод");
       }
       
       // 7. afterPropertiesSet() из InitializingBean
       @Override
       public void afterPropertiesSet() throws Exception {
           System.out.println("Шаг 7: InitializingBean.afterPropertiesSet()");
       }
       
       // 8. Кастомный init-метод (из XML/Java config)
       public void customInit() {
           System.out.println("Шаг 8: Кастомный init-метод (initMethod)");
       }
       
       // 9. Бизнес-метод
       public void doWork() {
           System.out.println("Шаг 9: Бизнес-метод doWork() выполняется");
       }
       
       // 10. @PreDestroy (JSR-250)
       @PreDestroy
       public void preDestroy() {
           System.out.println("Шаг 10: @PreDestroy метод");
       }
       
       // 11. destroy() из DisposableBean
       @Override
       public void destroy() throws Exception {
           System.out.println("Шаг 11: DisposableBean.destroy()");
       }
       
       // 12. Кастомный destroy-метод (из XML/Java config)
       public void customDestroy() {
           System.out.println("Шаг 12: Кастомный destroy-метод (destroyMethod)");
       }
   }
   ```

2. **Создайте конфигурационный класс, который определяет этот бин:**
   ```java
   @Configuration
   @ComponentScan(basePackages = "com.example.demo")
   public class AppConfig {
       
       @Bean(initMethod = "customInit", destroyMethod = "customDestroy")
       public LifecycleDemoBean lifecycleDemoBean() {
           LifecycleDemoBean bean = new LifecycleDemoBean();
           bean.setName("Демо-бин"); // Setter injection
           return bean;
       }
   }
   ```

3. **Создайте BeanPostProcessor для отслеживания дополнительных этапов:**
   ```java
   @Component
   public class DemoBeanPostProcessor implements BeanPostProcessor {
       
       @Override
       public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
           if (bean instanceof LifecycleDemoBean) {
               System.out.println("Этап между шагами: BeanPostProcessor.postProcessBeforeInitialization() для " + beanName);
           }
           return bean;
       }
       
       @Override
       public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
           if (bean instanceof LifecycleDemoBean) {
               System.out.println("Этап между шагами: BeanPostProcessor.postProcessAfterInitialization() для " + beanName);
           }
           return bean;
       }
   }
   ```

4. **Создайте main-класс для тестирования:**
   ```java
   public class Application {
       public static void main(String[] args) {
           System.out.println("=== Запуск Spring контекста ===");
           AnnotationConfigApplicationContext context = 
               new AnnotationConfigApplicationContext(AppConfig.class);
           
           System.out.println("\n=== Получение бина и выполнение бизнес-логики ===");
           LifecycleDemoBean bean = context.getBean(LifecycleDemoBean.class);
           bean.doWork();
           
           System.out.println("\n=== Закрытие контекста ===");
           context.close();
           System.out.println("=== Контекст закрыт ===");
       }
   }
   ```

**Ожидаемый вывод (примерно):**
```
=== Запуск Spring контекста ===
Шаг 1: Вызов конструктора
Шаг 2: Вызов сеттера для свойства 'name'
Шаг 3: BeanNameAware.setBeanName() - имя бина: lifecycleDemoBean
Шаг 4: BeanFactoryAware.setBeanFactory()
Шаг 5: ApplicationContextAware.setApplicationContext()
Этап между шагами: BeanPostProcessor.postProcessBeforeInitialization() для lifecycleDemoBean
Шаг 6: @PostConstruct метод
Шаг 7: InitializingBean.afterPropertiesSet()
Шаг 8: Кастомный init-метод (initMethod)
Этап между шагами: BeanPostProcessor.postProcessAfterInitialization() для lifecycleDemoBean

=== Получение бина и выполнение бизнес-логики ===
Шаг 9: Бизнес-метод doWork() выполняется

=== Закрытие контекста ===
Шаг 10: @PreDestroy метод
Шаг 11: DisposableBean.destroy()
Шаг 12: Кастомный destroy-метод (destroyMethod)
=== Контекст закрыт ===
```

## **Задание 2: Как "сломать" Spring контекст**

**Задача:** Показать опасные паттерны использования BeanPostProcessor.

**Шаги выполнения:**

1. **Создаем опасный BeanPostProcessor (обнаружение бесконечной рекурсии):**
   - В методе `postProcessAfterInitialization` проверяем тип бина
   - В условии вызываем context.getBean(), при котором будет заново создаваться указанный объект и проходить весь жизненный цикл
   - Пытаясь получить бин того же типа, spring обнаружит циклическую зависимость (вызывается эксепшен)

2. **Создаем опасный BeanPostProcessor (утечка памяти):**
   - Добавляем статическую коллекцию для хранения всех бинов
   - Сохраняем каждый обработанный бин в этой коллекции
   - Это создает утечку памяти, так как ссылки на бины никогда не освобождаются

3. **Запускаем и наблюдаем проблемы:**
   - Первый вариант может привести к StackOverflowError или бесконечному циклу
   - Второй вариант приводит к постоянному росту потребления памяти

```java
// Шаг 1: BeanPostProcessor с бесконечной рекурсией
@Component
public class BrokenProcessor implements BeanPostProcessor {

   @Autowired
   private ApplicationContext context;

   @Override
   public Object postProcessAfterInitialization(Object bean, String beanName) {
      if (bean instanceof SimpleService) {
         // Пытаемся получить бин того же типа. Spring обнаружит рекурсию 
         context.getBean(SimpleService.class);
      }
      return bean;
   }
}

// Шаг 2: BeanPostProcessor с утечкой памяти
@Component
public class LeakProcessor implements BeanPostProcessor {
    private static List<Object> ALL_BEANS = new ArrayList<>(); // Утечка!
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        ALL_BEANS.add(bean); // Сохраняем навсегда
        System.out.println("Захвачен бин: " + beanName);
        return bean;
    }
}
```


## **Вопрос: почему из-за данного конфига жизненный цикл не зациклится?**


```java
// Шаг 1: BeanPostProcessor с бесконечной рекурсией
@Component
public class BrokenProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        if (bean instanceof String) {
            // Каждый раз возвращаем новый объект
            return new String("broken"); // Spring будет обрабатывать его снова!
        }
        return bean;
    }
}

```