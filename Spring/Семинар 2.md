### **Семинар: Углубляемся в Spring Core — Жизненный цикл бинов и AOP**

**Цель:** На практике понять этапы жизни бина и принципы аспектно-ориентированного программирования в Spring.

**Задания:**

**1. Наблюдатель жизненного цикла (Простое наблюдение)**
*   **Задача:** Создайте бины, которые явно реагируют на события своего жизненного цикла.
*   **Действия:**
    1.  Создайте класс `DatabaseConnection` с полем `connectionId`.
    2.  Реализуйте метод с аннотацией `@PostConstruct`, который "устанавливает соединение" (выводит в консоль: `"Connection established for ID: ..."`).
    3.  Реализуйте метод с аннотацией `@PreDestroy`, который "закрывает соединение" (выводит в консоль: `"Connection closed for ID: ..."`).
    4.  Добавьте `@Component` и запустите приложение. Обязательно **закройте ApplicationContext** (`.close()`), чтобы увидеть срабатывание `@PreDestroy`.

**Решение:**
```java
@Component
public class DatabaseConnection {
    private String id = UUID.randomUUID().toString();
    
    @PostConstruct
    public void connect() {
        System.out.println("Connection established for ID: " + id);
    }
    
    @PreDestroy
    public void disconnect() {
        System.out.println("Connection closed for ID: " + id);
    }
}

// Main.java
public static void main(String[] args) {
    ConfigurableApplicationContext ctx = 
        new AnnotationConfigApplicationContext(AppConfig.class);
    // работа с контекстом
    ctx.close(); // вызовет @PreDestroy
}
```

---

**2. BeanPostProcessor для валидации полей**
*   **Задача:** Создать BeanPostProcessor, который автоматически проверяет поля бинов, помеченные специальной аннотацией.

*   **Действия:**

1. **Создаем аннотацию `@ValidRange`:**
    - Аннотируем для использования на полях (`@Target(ElementType.FIELD)`)
    - Добавляем параметры `min()` и `max()` для задания диапазона

2. **Создаем BeanPostProcessor:**
    - Реализуем интерфейс `BeanPostProcessor`
    - В методе `postProcessBeforeInitialization` ищем поля с аннотацией `@ValidRange`
    - Проверяем, что значение поля находится в указанном диапазоне
    - Выводим сообщение об ошибке при нарушении валидации

3. **Создаем тестовый бин:**
    - Создаем класс `ConfigBean` с полем, помеченным `@ValidRange`
    - Устанавливаем значение, нарушающее условия валидации

4. **Запускаем и проверяем:**
    - Создаем Spring контекст с компонентом `ConfigBean`
    - Наблюдаем вывод сообщения об ошибке валидации при создании бина

```java
// Шаг 1: Создаем аннотацию
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ValidRange {
    int min() default 0;
    int max() default 100;
}

// Шаг 2: Создаем BeanPostProcessor
@Component
public class ValidationProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        for (Field field : bean.getClass().getDeclaredFields()) {
            ValidRange ann = field.getAnnotation(ValidRange.class);
            if (ann != null) {
                field.setAccessible(true);
                try {
                    int value = (int) field.get(bean);
                    if (value < ann.min() || value > ann.max()) {
                        System.out.println("Ошибка: " + field.getName() + 
                                         " = " + value + " вне диапазона " + 
                                         ann.min() + ".." + ann.max());
                    }
                } catch (Exception e) {
                   System.out.println("Обработка исключения ...");
                }
            }
        }
        return bean;
    }
}

// Шаг 3: Создаем тестовый бин
@Component
public class ConfigBean {
    @ValidRange(min = 1, max = 10)
    private int attempts = 15; // Нарушает условие валидации
}
```

---

**3. Аспект для логирования (Базовое применение AOP)**
*   **Задача:** Создать первый аспект для сквозной функциональности.
*   **Действия:**
    1.  Создайте сервис `PaymentService` с методом `processPayment(amount)`.
    2.  Создайте аспект-класс `LoggingAspect`.
    3.  Определите advice `@Before`, который срабатывает для метода `processPayment` и выводит в консоль: `"[LOG] Вызов processPayment с аргументом: ..."`.
    4.  Убедитесь, что AOP включена (добавьте `@EnableAspectJAutoProxy` в конфигурацию).
    5.  Вызовите метод сервиса через `@PostConstruct` и проверьте лог.

**Решение:**
```java
@Service
public class PaymentService {
    public void processPayment(double amount) {
        // бизнес-логика
    }
}

@Aspect
@Component
public class LoggingAspect {
    @Before("execution(* PaymentService.processPayment(double)) && args(amount)")
    public void logBefore(double amount) {
        System.out.println("[LOG] Вызов processPayment с аргументом: " + amount);
    }
}

@Configuration
@EnableAspectJAutoProxy
@ComponentScan
public class AppConfig {}

@Component
public class Starter {

    @Autowired
    private PaymentService paymentService;

    @PostConstruct
    public void init() {
        // Вызывается при создании бина - аспект сработает
        paymentService.validatePayment(-5);
    }
}
```

---

**4. Аспект для обработки исключений (Усложнение AOP)**
*   **Задача:** Использовать AOP для централизованной обработки ошибок.
*   **Действия:**
    1.  Добавьте в `PaymentService` метод `validatePayment(amount)`, который при `amount <= 0` выбрасывает `IllegalArgumentException`.
    2.  В аспекте `LoggingAspect` создайте advice `@AfterThrowing`, который перехватывает это исключение и логирует ошибку: `"[ERROR] В методе validatePayment произошла ошибка: ..."`.
    3.  **Усложнение:** Используйте `@Around` advice, чтобы не только перехватить исключение, но и вернуть вызывающему коду стандартное значение (например, `false`) вместо проброса исключения.

**Решение:**
```java
@Service
public class PaymentService {
    public boolean validatePayment(double amount) {
        if (amount <= 0) throw new IllegalArgumentException("Invalid amount");
        return true;
    }
}

@Aspect
@Component
public class LoggingAspect {
    @AfterThrowing(pointcut="execution(* validatePayment(..))", throwing="ex")
    public void logError(IllegalArgumentException ex) {
        System.out.println("[ERROR] Ошибка: " + ex.getMessage());
    }
    
    @Around("execution(* validatePayment(..))")
    public Object handleError(ProceedingJoinPoint pjp) {
        try {
            return pjp.proceed();
        } catch (Throwable e) {
            System.out.println("[AROUND] Перехвачена ошибка");
            return false; // возвращаем значение по умолчанию
        }
    }
}
```

---

**5. Кастомные аннотации для AOP**
*    **Задача:** Создать аннотацию для выборочного применения аспектов.

**Решение:**
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MonitorTime {}

@Aspect
@Component
public class TimeAspect {
    @Around("@annotation(MonitorTime)")
    public Object monitor(ProceedingJoinPoint pjp) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = pjp.proceed();
        long time = System.currentTimeMillis() - start;
        System.out.println("Время выполнения: " + time + "ms");
        return result;
    }
}

@Service
public class PaymentService {
    @MonitorTime
    public void processPayment(double amount) {
        // бизнес-логика
    }
}
```
